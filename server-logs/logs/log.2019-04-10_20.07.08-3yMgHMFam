./run.sh examples/decentralized-lock-simple.ivy 4 4

Z3 version 4.8.4 - 64 bit

6a7678927d1532d5149efdeff427ca6547513a19

diff --git a/src/main.cpp b/src/main.cpp
index e1dd7e9..faab94f 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -536,7 +536,7 @@ int main(int argc, char* argv[]) {
   printf("random seed = %d\n", seed);
   srand(seed);
 
-  try {
+  //try {
     if (!just_enumeration) {
       assert(module->templates.size() == 1);
       /*
@@ -586,8 +586,8 @@ int main(int argc, char* argv[]) {
       std::cout << "end" << std::endl;
     }
 
-  } catch (z3::exception exc) {
-    printf("got z3 exception: %s\n", exc.msg());
-    throw;
-  }
+  //} catch (z3::exception exc) {
+  //  printf("got z3 exception: %s\n", exc.msg());
+  //  throw;
+  //}
 }

random seed = 1234
depth = 4, arity = 4
bmc_depth = 4

solver (1) : 267 ms
candidate: forall A . (forall B . (forall C . (forall E . (forall F . (OR[])))))
counterexample type: INIT
Model sizes: node: 1, time: 1

solver (2) : 740 ms
candidate: forall A . (forall B . (forall C . (forall E . (forall F . (AND[])))))
counterexample type: SAFETY
Model sizes: node: 2, time: 1

solver (3) : 1090 ms
candidate: forall A . (forall B . (forall C . (forall E . (forall F . (~(has_lock(B)))))))
counterexample type: INIT
Model sizes: node: 1, time: 1

solver (4) : 66 ms
candidate: forall A . (forall B . (forall C . (forall E . (forall F . ((B) = (C))))))
counterexample type: INIT
Model sizes: node: 2, time: 1

solver (5) : 1428 ms
candidate: forall A . (forall B . (forall C . (forall E . (forall F . ((OR[]) | ((A) = (C)) | (~(has_lock(C))) | (~(le(F, F))))))))
counterexample type: INIT
Model sizes: node: 2, time: 1

solver (6) : 354 ms
candidate: forall A . (forall B . (forall C . (forall E . (forall F . ((((~(has_lock(A))) | (~(has_lock(C))) | (~(le(E, E))) | (~(le(E, F)))) & (has_lock(B)) & (~(msg(B, B, E))) & (~(msg(B, B, E)))) | ((A) = (C)) | (~(has_lock(B))) | (~(le(F, F))))))))
counterexample type: INIT (after some steps)
Model sizes: node: 4, time: 3

solver (7) : 17269 ms
candidate: forall A . (forall B . (forall C . (forall E . (forall F . ((((~(has_lock(A))) | (~(has_lock(C))) | (~(le(E, E))) | (~(le(E, E)))) & (has_lock(B)) & (~(msg(A, B, E))) & (~(msg(A, B, E)))) | ((A) = (B)) | (~(has_lock(B))) | (~(has_lock(B))))))))
counterexample type: INIT (after some steps)
Model sizes: node: 4, time: 4

solver (8) : 2808886 ms
candidate: forall A . (forall B . (forall C . (forall E . (forall F . ((((~(has_lock(A))) | (~(has_lock(C))) | (~(le(E, E))) | (~(le(E, E)))) & (has_lock(B)) & (~(msg(A, B, epoch(A)))) & (~(msg(B, A, E)))) | ((A) = (B)) | (~(has_lock(B))) | (~(has_lock(B))))))))
counterexample type: INIT (after some steps)
Model sizes: node: 5, time: 5

solver (9) : 153204 ms
candidate: forall A . (forall B . (forall C . (forall E . (forall F . ((((~(has_lock(A))) | (~(has_lock(C))) | (~(le(E, F))) | (~(le(E, F)))) & (has_lock(B)) & (~(msg(A, B, epoch(A)))) & (~(msg(B, A, epoch(B))))) | ((A) = (B)) | (~(has_lock(B))) | (~(has_lock(B))))))))
counterexample type: INDUCTIVE
Model sizes: node: 2, time: 2

solver (10) : 427393 ms
candidate: forall A . (forall B . (forall C . (forall E . (forall F . ((OR[]) | ((A) = (C)) | (~(has_lock(A))) | (~(has_lock(C))))))))
counterexample type: INDUCTIVE
simplifying -> SAFETY
Model sizes: node: 2, time: 2

solver (11) : 31079 ms
candidate: forall A . (forall B . (forall C . (forall E . (forall F . ((((AND[]) & (has_lock(B)) & (~(has_lock(C))) & (~(msg(C, C, E)))) & (has_lock(B)) & (has_lock(B)) & (has_lock(B))) | ((A) = (C)) | (~(has_lock(A))) | (~(has_lock(B))))))))
counterexample type: INIT (after some steps)
Model sizes: node: 5, time: 5

solver (12) : 8903092 ms
candidate: forall A . (forall B . (forall C . (forall E . (forall F . (((OR[]) | (OR[]) | (OR[]) | (~(has_lock(A)))) | ((OR[]) | (OR[]) | (~(le(epoch(A), E))) | (~(le(F, F)))) | (((has_lock(A)) & (~(has_lock(C))) & (~(msg(A, C, E))) & (~(msg(A, C, E)))) | (~(has_lock(B))) | (~(has_lock(B))) | (~(has_lock(B)))) | ((A) = (C)))))))
counterexample type: INDUCTIVE
simplifying -> SAFETY
Model sizes: node: 2, time: 2

solver (13) : 4138302 ms
candidate: forall A . (forall B . (forall C . (forall E . (forall F . (((AND[]) & ((OR[]) | ((OR[]) & (OR[]) & (OR[]) & (OR[])) | (~(has_lock(A))) | (~(msg(B, C, F)))) & ((OR[]) | (~(has_lock(A))) | (~(has_lock(C))) | (~(le(F, F)))) & ((OR[]) | (~(has_lock(C))) | (~(msg(A, A, E))) | (~(msg(A, C, E))))) | ((OR[]) & (msg(B, A, E)) & (~(le(epoch(B), epoch(C)))) & (~(le(epoch(B), E)))) | ((A) = (C)) | (~(le(epoch(A), F))))))))
counterexample type: INDUCTIVE
Model sizes: node: 2, time: 2

solver (14) : 19054533 ms
candidate: forall A . (forall B . (forall C . (forall E . (forall F . ((((AND[]) & ((A) = (B)) & (~(le(E, F))) & (~(le(E, F)))) | (((AND[]) | (AND[]) | (AND[]) | (AND[])) & ((B) = (B)) & (msg(A, B, E)) & (~(msg(C, A, F)))) | ((has_lock(A)) & (msg(A, B, E)) & (msg(A, B, F)) & (msg(A, C, E))) | (~(has_lock(C)))) | ((((B) = (B)) & ((B) = (B)) & ((B) = (C)) & (le(E, F))) | (~(has_lock(B))) | (~(has_lock(C))) | (~(has_lock(C)))) | (~(has_lock(C))) | (~(le(epoch(C), epoch(A)))))))))
counterexample type: INIT
Model sizes: node: 2, time: 2

solver (15) : 6279191 ms
candidate: forall A . (forall B . (forall C . (forall E . (forall F . (((OR[]) | (OR[]) | (~(le(epoch(B), epoch(C)))) | (~(le(epoch(C), E)))) | ((((A) = (B)) & (le(F, E)) & (le(F, E)) & (le(F, E))) | (((A) = (C)) & (le(E, F)) & (~(has_lock(A))) & (~(msg(C, C, E)))) | (((B) = (B)) & (~(le(E, E))) & (~(le(E, E))) & (~(le(E, F)))) | (((B) = (C)) & (~(msg(A, A, F))) & (~(msg(A, A, F))) & (~(msg(A, A, F))))) | (~(has_lock(A))) | (~(has_lock(B))))))))
counterexample type: INIT
Model sizes: node: 2, time: 2

solver (16) : 10889800 ms
candidate: forall A . (forall B . (forall C . (forall E . (forall F . (((OR[]) | ((AND[]) & ((F) = (F)) & (msg(B, A, F)) & (~(msg(C, B, E)))) | (~(le(epoch(B), epoch(B)))) | (~(le(epoch(B), epoch(C))))) | ((OR[]) | ((AND[]) & (has_lock(B)) & (le(F, E)) & (msg(B, C, E))) | ((AND[]) & (~(le(E, E))) & (~(le(E, F))) & (~(le(E, F)))) | (~(le(epoch(C), epoch(B))))) | ((((A) = (C)) & (has_lock(C)) & (has_lock(C)) & (~(msg(B, B, F)))) | ((~(le(E, F))) & (~(le(F, E))) & (~(msg(A, B, E))) & (~(msg(C, A, E)))) | ((OR[]) | (OR[]) | (OR[]) | (OR[])) | ((~(has_lock(A))) | (~(has_lock(A))) | (~(has_lock(C))) | (~(le(E, F))))) | (((OR[]) | (~(le(E, E))) | (~(le(E, E))) | (~(le(F, F)))) | (~(le(E, F))) | (~(le(E, F))) | (~(le(E, F)))))))))
counterexample type: SAFETY
Model sizes: node: 2, time: 1

solver (17) : 87687 ms
candidate: forall A . (forall B . (forall C . (forall E . (forall F . (((OR[]) | ((AND[]) & ((F) = (F)) & (msg(B, A, F)) & (~(msg(A, B, E)))) | (~(le(epoch(B), epoch(B)))) | (~(le(epoch(B), epoch(C))))) | ((OR[]) | ((AND[]) & (has_lock(B)) & (le(F, E)) & (msg(B, C, E))) | ((AND[]) & (~(le(E, E))) & (~(le(E, F))) & (~(le(E, F)))) | (~(le(epoch(C), epoch(B))))) | ((((A) = (C)) & (has_lock(C)) & (has_lock(C)) & (~(msg(B, B, F)))) | ((~(le(E, F))) & (~(le(F, E))) & (~(msg(A, B, E))) & (~(msg(C, A, E)))) | ((OR[]) | (OR[]) | (OR[]) | (OR[])) | ((~(has_lock(A))) | (~(has_lock(A))) | (~(has_lock(C))) | (~(le(E, F))))) | (((OR[]) | (~(le(E, E))) | (~(le(E, E))) | (~(le(F, F)))) | (~(le(E, F))) | (~(le(E, F))) | (~(le(E, F)))))))))
counterexample type: SAFETY
Model sizes: node: 2, time: 1

